# A testnet deployment for the token, wallet and vault ONLY
# IMPORTANT: Remember to token.transferOwnership(deploy_address)
rinkeby:

    # Chain we are connected to.
    # Either "mainnet" or "ropsten".
    # Affects Etherscan verification process only.
    chain: rinkeby

    # Do we perform deployed contract source code verification on etherscan.io service.
    # This is a semi automatic process using a Chrome browser.
    verify_on_etherscan: yes

    #               B  M  k   tokens
    totalCoins:    1000000000
    totalTeamCoins: 150000000
    companyCoins:   150000000

    #
    # Contracts section defines different smart contracts that
    # are required to run the ICO.
    #
    contracts:

        # Company multisignature wallet.
        #
        # Multiple escrow key holders are required to take action to move
        # funds around.
        #
        # All crowdsale collected funds are deposited to the this multisig wallet in real time.
        #
        company_wallet:
            contract_name: MultiSigWallet
            contract_file: GnosisWallet.sol
            address: "0x92905b1f4c7c599d575cbef3fd00c5b161666cc6"

        #
        # Token contract
        #
        # This contract represents ERC-20 token.
        # It has transfer lock up functionality to prevent the token to be transferable
        # until the ICO is over. Furthermore it has dynamic minting supply,
        # so that the crowdsale contract will create new tokens as contributions arrives in.
        # This way, there is no need for a separate burn stage at the end of the crowdsale,
        # as we never create the exceeding supply.
        #
        #
        token:
            contract_name: CrowdsaleToken
            contract_file: CrowdsaleToken.sol
            address: "0x806a07831684c7cfa5f17e27490c939ce63b34fc"

        #
        # Pricing strategy
        #
        # Pricing strategy defines the price of a token in the different stages of the crowdsale.
        # Here we use milestone based pricing that has a different price for the token every week of the crowdale.
        #
        #
        pricing_strategy:
            contract_name: FlatPricing
            contract_file: FlatPricing.sol
            arguments:
                # 1 ETH = 1000 token  => 10^18 wei = 1000 token => 1 token = 10^18 wei / 1000
                _oneTokenInWei: "{{ (10**18 / 1000000000 ) | round | int }}"

        #
        # Crowdsale
        #
        # This is the actual crowdsale contract.
        # It will accept contributions during the crowdsale time period.
        # For each contributions, it asks the pricing contract for the
        # current price for this particular contributor.
        #
        #
        #
        crowdsale:
            contract_name: MintedTokenCappedCrowdsale
            contract_file: MintedTokenCappedCrowdsale.sol
            arguments:
                _token: "{{contracts.token.address}}"
                _pricingStrategy: "{{contracts.pricing_strategy.address}}"
                _multisigWallet: "{{contracts.company_wallet.address}}"
                _start: "{{ time() + 5*60 }}"
                _end: "{{ time() + 15*60 }}"
                #_start: "{{ timestamp(datetime(2017, 7, 14, 16, 0)) }}" what timezone is this?
                #_end: "{{ timestamp(datetime(2017, 7, 14, 16, 0)) + 30*24*3600 }}" what timezone is this?
                _minimumFundingGoal: 0
                _maximumSellableTokens: "{{ (totalCoins - totalTeamCoins - companyCoins) * 10**18 }}" # in "atomic units" (10^18 per full token)
        #
        # Finalize contract
        #
        # Finalize contract defines what happens at the end of the successful crowdsale.
        #
        # The bonus finalize agent we define here 1) makes tokens transferable by releasing
        # the transfer restrictions 2) mints 25% new tokens for the team to be
        # reserved for founders, bounties and such. These new tokens are deposited in the
        # team multisig wallet.
        #
        finalize_agent:
            contract_name: DefaultFinalizeAgent
            contract_file: DefaultFinalizeAgent.sol
            arguments:
                _token: "{{contracts.token.address}}"
                _crowdsale: "{{contracts.crowdsale.address}}"

    # Post-deployment actions connect contracts together.
    # They set ownership and allowed actions, so that contracts can interact
    post_actions: |
        # BEFORE RUNNING: Remember to token.transferOwnership(deploy_address)

        # Enable new token minting by a crowdsale contract
        token.transact({"from": deploy_address}).setMintAgent(crowdsale.address, True)

        # Set actions what happen at the end of the crodsale.
        # Enable token mintint at the end of the crowdsale to create bonus pool, founder pool and such
        crowdsale.transact({"from": deploy_address}).setFinalizeAgent(finalize_agent.address)
        token.transact({"from": deploy_address}).setReleaseAgent(finalize_agent.address)

        # Presale allocations
        crowdsale.transact({"from": deploy_address}).preallocate("0xb3428050eA2448eD2E4409bE47E1a50EBac0B2d2", 55 * 10**6 * 10**18, 5870 * 10**18)

        # Move ownership of all owned contracts to the company address
        crowdsale.transact({"from": deploy_address}).transferOwnership(company_wallet.address)
        token.transact({"from": deploy_address}).transferOwnership(company_wallet.address)

    # Make sure that everything we have deployed all contracts in good state
    # and their internal state is sane
    verify_actions: |
        assert token.call().owner() == company_wallet.address
        assert crowdsale.call().owner() == company_wallet.address
        assert finalize_agent.call().isSane()
        assert crowdsale.call().getState() == CrowdsaleState.PreFunding
        assert crowdsale.call().tokensSold() == 55 * 10**6 * 10**18
        assert token.call().totalSupply() == (totalTeamCoins + companyCoins) * 10**18 + crowdsale.call().tokensSold()
