# A testnet deployment for the token, wallet and vault ONLY
rinkeby:

    # Chain we are connected to.
    # Either "mainnet" or "ropsten".
    # Affects Etherscan verification process only.
    chain: rinkeby

    # Do we perform deployed contract source code verification on etherscan.io service.
    # This is a semi automatic process using a Chrome browser.
    verify_on_etherscan: yes

    #               B  M  k   tokens
    totalCoins:    1000000000
    totalTeamCoins: 150000000
    companyCoins:   150000000

    #
    # Contracts section defines different smart contracts that
    # are required to run the ICO.
    #
    contracts:

        # Company multisignature wallet.
        #
        # Multiple escrow key holders are required to take action to move
        # funds around.
        #
        # All crowdsale collected funds are deposited to the this multisig wallet in real time.
        #
        company_wallet:
            contract_name: MultiSigWallet
            contract_file: GnosisWallet.sol
            arguments:
                _owners:
                    - "0xf292c7c8ad3ce239e31132fe7bbaa4600e940faf"
                    - "0x5d59280c8d3d4bf75cd4a4c6c1e23d00d8735a56"
                    - "0xf210482142bfdc654b7621b1e461812851176799"
                _required: 2

        #
        # Token contract
        #
        # This contract represents ERC-20 token.
        # It has transfer lock up functionality to prevent the token to be transferable
        # until the ICO is over. Furthermore it has dynamic minting supply,
        # so that the crowdsale contract will create new tokens as contributions arrives in.
        # This way, there is no need for a separate burn stage at the end of the crowdsale,
        # as we never create the exceeding supply.
        #
        #
        token:
            contract_name: CrowdsaleToken
            contract_file: CrowdsaleToken.sol
            arguments:
                _name: DATAcoin-test
                _symbol: DATA
                _initialSupply: 0
                _decimals: 18
                _mintable: true

        # Token vault for freezing team's tokens
        team_vault:
            contract_name: TokenVault
            contract_file: TokenVault.sol
            arguments:
                #_owner: "{{contracts.company_wallet.address}}"
                _freezeEndsAt: "{{ time() + 35*60 }}" # 35 minute freeze
                _token: "{{contracts.token.address}}"
                _tokensToBeAllocated: "{{ totalTeamCoins * 10**18 }}" # in "atomic units" (10^18 per full token)

    # Post-deployment actions connect contracts together.
    # They set ownership and allowed actions, so that contracts can interact
    post_actions: |
        # Mint coins for team and company
        token.transact({"from": deploy_address}).setMintAgent(deploy_address, True)
        token.transact({"from": deploy_address}).mint(company_wallet.address, companyCoins * 10**18)
        token.transact({"from": deploy_address}).mint(team_vault.address, totalTeamCoins * 10**18)
        token.transact({"from": deploy_address}).setMintAgent(deploy_address, False)

        # Team allocations, in "atomic units" (10^18 per full token)
        team_vault.transact({"from": deploy_address}).setInvestor("0xd67f5fea79e3196de8c1bde7f9d8f05fdbb1a1ef", 50 * 10**6 * 10**18)
        team_vault.transact({"from": deploy_address}).setInvestor("0x90e7f3137baf2e1d594198fa2db56b0e71600359", 30 * 10**6 * 10**18)
        team_vault.transact({"from": deploy_address}).setInvestor("0x169a815053fcf86ffa6f22aaa63e0acd90357035", 40 * 10**6 * 10**18)
        team_vault.transact({"from": deploy_address}).setInvestor("0x8776bff824663b37deaf6126dfca519ecface784", 5 * 10**6 * 10**18)
        team_vault.transact({"from": deploy_address}).setInvestor("0xf9e285e60bcbfa4aa3cf76d2e8103656b47e5e84", 5 * 10**6 * 10**18)
        team_vault.transact({"from": deploy_address}).setInvestor("0x8c31be58def186fecd0836dbbb5d43abbe5d401b", 5 * 10**6 * 10**18)

        # TEST ALLOCATION to fill up the vault
        team_vault.transact({"from": deploy_address}).setInvestor("0xDdc8963569BC7f237FEe4EAf129d26D276FcF22e", 15 * 10**6 * 10**18)

        token.transact({"from": deploy_address}).transferOwnership(company_wallet.address)
        token.transact({"from": deploy_address}).setUpgradeMaster(company_wallet.address)
        team_vault.transact({"from": deploy_address}).transferOwnership(company_wallet.address)

    # Make sure that everything we have deployed all contracts in good state
    # and their internal state is sane
    verify_actions: |
        #assert team_vault.call().getState() == 1    # State.Loading
        #assert team_vault.call().getState() == 2    # State.Holding
